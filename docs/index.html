<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Argo: Argo JSON Library Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="argo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Argo
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A C++ library for handling JSON.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Argo JSON Library Main Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="first"></a>
Yet Another JSON Library?!</h1>
<p>Well, coders always think we can do better, don't we? I orginally wrote this a few years back as part of another project when there weren't any C++ JSON libraries I could find that didn't leave me banging my head on the desk in frustration. Since then many good options have come along and <a href="https://github.com/miloyip">Milo Yip</a> has done an outstanding job of <a href="https://github.com/miloyip/nativejson-benchmark">testing and cataloging</a> many of them.</p>
<p>Anyway, this one is, I think, nice to use and the combination of performance and error checking is strong so I think it's worth publishing.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<h2><a class="anchor" id="hello"></a>
Hello World</h2>
<p>All of these examples can be found in json_example.cpp. json_test.cpp also includes a lot of example code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="argo_8hpp.html">argo.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    std::string s = <span class="stringliteral">&quot;{\&quot;one\&quot; : \&quot;hello world\&quot;}&quot;</span>;</div><div class="line">    <a class="code" href="classargo_1_1json.html">argo::json</a> j;</div><div class="line">    s &gt;&gt; j;</div><div class="line">    std::cout &lt;&lt; j[<span class="stringliteral">&quot;one&quot;</span>] &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="file"></a>
Read From File &amp; Write To File</h2>
<p>Read a JSON message from one file and write it back out to another.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="argo_8hpp.html">argo.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> j = <a class="code" href="classargo_1_1parser.html#aea46bdbc47437bb5739b6c93b20ec3e7">argo::parser::load</a>(<span class="stringliteral">&quot;test_files/test2.json&quot;</span>);</div><div class="line">    <a class="code" href="classargo_1_1unparser.html#a0d71fd5f3a7a2e54a47ca98ffc9478e0">argo::unparser::save</a>(*j, <span class="stringliteral">&quot;test_files/tmp.json&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="construct"></a>
Construct A Message From Scratch</h2>
<p>Create an object with some scalar values in it:</p>
<div class="fragment"><div class="line"><span class="comment">// create an object</span></div><div class="line"><a class="code" href="classargo_1_1json.html">argo::json</a> j(argo::json::object_e);</div><div class="line"></div><div class="line"><span class="comment">// add some values</span></div><div class="line">j[<span class="stringliteral">&quot;one&quot;</span>] = 1;</div><div class="line">j[<span class="stringliteral">&quot;two&quot;</span>] = 2.0;</div><div class="line">j[<span class="stringliteral">&quot;three&quot;</span>] = <span class="stringliteral">&quot;three&quot;</span>;</div><div class="line">j[<span class="stringliteral">&quot;four&quot;</span>] = <span class="keyword">true</span>;</div><div class="line">j[<span class="stringliteral">&quot;five&quot;</span>] = <span class="keyword">false</span>;</div><div class="line">j[<span class="stringliteral">&quot;six&quot;</span>] = <span class="keyword">nullptr</span>; <span class="comment">// null - can also use json()</span></div><div class="line"></div><div class="line"><span class="comment">// print it</span></div><div class="line">std::cout &lt;&lt; j &lt;&lt; std::endl;</div></div><!-- fragment --><h2><a class="anchor" id="pointers"></a>
Extract a value using a JSON pointer.</h2>
<p>Given the following JSON in a file named foo.json: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   &quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;],</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   &quot;&quot;: 0,</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   &quot;a/b&quot;: 1,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   &quot;c%d&quot;: 2,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   &quot;e^f&quot;: 3,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   &quot;g|h&quot;: 4,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   &quot;i\\j&quot;: 5,</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   &quot;k\&quot;l&quot;: 6,</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   &quot; &quot;: 7,</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   &quot;m~n&quot;: 8</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><p> Extract the value of the zeroeth element of the foo array:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> j = <a class="code" href="classargo_1_1parser.html#aea46bdbc47437bb5739b6c93b20ec3e7">argo::parser::load</a>(<span class="stringliteral">&quot;foo.json&quot;</span>);</div><div class="line">std::cout &lt;&lt; j-&gt;find(<a class="code" href="classargo_1_1pointer.html">argo::pointer</a>(<span class="stringliteral">&quot;/foo/0&quot;</span>)) &lt;&lt; std::endl;</div></div><!-- fragment --><h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>The Argo library provides a set of C++ classes for manipulating JSON structures as defined by <a href="https://tools.ietf.org/html/rfc7159">RFC7159</a>. It was designed with the following goals in mind:</p><ul>
<li>Ease of use. C++'s type system doesn't map naturally onto the dynamic type systems used by Javascript, Python and others. The aim is to provide an interface that is brief and intuitive.</li>
<li>Performance. If you're using C++ then you probably care about performance. Argo provides efficient ways to manipulate large JSON structures whilst still providing coding simplicity for smaller ones.</li>
<li>Flexibility. Not all JSON messages follow the standard. Argo allows calling code to decide how to handle some of those situations should it choose to.</li>
<li>Conformant. Every attempt has been made to conform to the <a href="https://tools.ietf.org/html/rfc7159">RFC</a>.</li>
</ul>
<h1><a class="anchor" id="featured"></a>
Features</h1>
<p>Argo has a number of features:</p><ul>
<li>Concise API.</li>
<li>Direct handling of multiple IO styles (streams, FILEs, file descriptors, strings).</li>
<li>DOM style representation of JSON messages.</li>
<li>JSON Pointer access as per <a href="https://tools.ietf.org/html/rfc6901">RFC6901</a>.</li>
<li><a href="https://tools.ietf.org/html/rfc7159">RFC7159</a> compliance.</li>
<li>Full unicode support.</li>
<li>Good performance in the context of the amount of error checking carried out.</li>
<li>No dependence on Boost or any other set of external libraries.</li>
<li>Lots of built in error and limit checking.</li>
<li>Reasonably comprehensive documentation.</li>
</ul>
<h1><a class="anchor" id="dependencies"></a>
Dependencies</h1>
<p>The library has no external dependencies beyond the C++ standard libraries. It does however make use of several C++11 features and therefore needs a compiler that supports them. The code was developed using GCC 4.8 but also built and tested with Visual Studio 2017.</p>
<p>If you want to build the documentation you'll also need doxygen installed.</p>
<h1><a class="anchor" id="unicode"></a>
Unicode Strings, Unicode and UTF-8</h1>
<p>JSON messages can contain unicode characters (encoded as UTF-8) directly or in the form of \u sequences. E.g.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &quot;one&quot;   : &quot;\u2100&quot;,       // Unicode character for A/C</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &quot;two&quot;   : &quot;\uD834\uDD1E&quot;, // Unicode character for the G (or treble) cleff</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &quot;three&quot; : &quot;ðŸ˜‚ &quot;,          // Directly embedded unicode emoji</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &quot;three&quot; : &quot;\ud83d\ude02&quot;  // The same emoji in \u form</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><p>When reading, Argo handles translates everything into <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. When writing it encodes all unicode characaters using \u sequences.</p>
<h1><a class="anchor" id="numbers"></a>
Numbers, Ints and Doubles</h1>
<p>JSON has just numbers. C++, on the other hand, has ints and doubles. When parsing messages Argo handles this as follows:</p><ul>
<li>if the number is an integer (i.e. if it consists of a sequence of 0-9 digits and an options leading '-' sign) then it is parsed as an integer. If it is out of range for the int POD type, then, if the parser fallback_to_double option is true (the default) an attempt is then made to convert it to a double instead, otherwise parsing fails and an exception is thrown.</li>
<li>if the number is floating point, (e.g. 1.2, 3e+10 etc.) then Argo attempts to convert it to a double. If it is out of range, then parsing fails and an exception is thrown.</li>
</ul>
<p>An option is provided for programs that need to handle larger numbers using code of their own whereby numbers are syntax checked only and returned as a string for conversion by the caller.</p>
<h2><a class="anchor" id="precision"></a>
Floating Point Precision</h2>
<p>Turning floating point numbers into strings is <a href="http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/">harder than it looks</a>. Argo take the approach of writing doubles to the full available precision (17 digits) which means that, in string terms, what comes out will not always match what comes out of a Python or Javascript (or other) program but, in numeric terms once parsed and held in an IEEE floating point number, will. If you care about the exact formatting of floating point numbers in your output file then use the json(json::number_double_e, "123.5678") constructor to control the exact output format. To produce optimal number strings (broadly the shortest string that produces the exact same floating point number when converted back) from C++ code I recommend <a href="https://github.com/google/double-conversion/blob/master/double-conversion/strtod.h">Google's double conversion library</a>.</p>
<h2><a class="anchor" id="raw"></a>
Raw Values</h2>
<p>Argo offers the option to parse JSON messages without converting strings into UTF-8 and without converting numbers into ints or doubles. This allows calling code to handle its own coversions in the case where string values may be invalid (e.g. formatting issues or invalid unicode code points) or where numbers may be too large to fit into the standard types. String and number raw values (created using the json(type, raw_value) constructor) behave differently to normally constructed objects in the following ways: </p><pre class="fragment">- Cast operators will throw an exception.
- Comparison operators (== != &lt; &gt; &lt;= &gt;=) will throw an exception.
</pre><p>If you need to compare them then you must handle your own conversion on the string returned by get_raw_value().</p>
<h2><a class="anchor" id="casting"></a>
Casting Values</h2>
<p>Doubles and ints may be cast to each other and the usual C/C++ conventions of type promotion are followed by all the relevant operators. Ints, but not doubles, may be cast to booleans.</p>
<h1><a class="anchor" id="sizes"></a>
Maximum Lengths</h1>
<p>The default maximum length of a lexical token (e.g. a string, a number, a keyword) is defined in <a class="el" href="parser_8hpp.html" title="The parser class. ">parser.hpp</a> and is set to 100K. This is almost certainly enough for 99.99% of all known applications but the option exists to specify a different number at run time via parameters to the parse class constructor.</p>
<h1><a class="anchor" id="threads"></a>
Thread Safety</h1>
<p>The library uses only thread safe system calls and has no global variables that are not also constant. This means that multiple threads can safely parse and uparse messages at the same time and that multiple threads can safely call const methods on a shared json instance. Simultaneous update/read or update/update operations on a json instance are not thread safe. This is the same thread safety model implemented by STL containers.</p>
<h1><a class="anchor" id="performance"></a>
Efficiency Peformance vs. Convenience</h1>
<p>The Argo json class comes with a copy constructor and an assignment operator. For small objects they're convient to use and don't come with too much of a performance hit. E.g. this is probably fine unless you're doing a very large number of times in a tight loop:</p>
<div class="fragment"><div class="line">json j1;</div><div class="line">j1[<span class="stringliteral">&quot;a&quot;</span>] = 1;</div><div class="line">j1[<span class="stringliteral">&quot;b&quot;</span>] = <span class="stringliteral">&quot;a string&quot;</span>;</div><div class="line">j1[<span class="stringliteral">&quot;c&quot;</span>] = <span class="keyword">true</span>;</div><div class="line">json j2(j1);</div></div><!-- fragment --><p>However, if you're handling large structures then you need to put a more effort in to ensure efficiency. The parser() class returns unique_ptrs to instances for this reason and there are specific versions of the json.append and json.insert methods that also work with pointers. In addition there is a json move constructor and a json move assignment operator which can remove the need for explicit pointer operations in many cases.</p>
<h1><a class="anchor" id="installing"></a>
Installation</h1>
<h2><a class="anchor" id="all"></a>
All Operating Systems &amp; Compilers</h2>
<p>The simplest way to install Argo is to include the code in your own project and then build it along with everything else. All the .hpp files and all the .cpp files are needed except for <a class="el" href="documentation_8hpp.html" title="A file containing just documentation for doxygen to pick up and put on the main page. ">documentation.hpp</a>, json_test.cpp and json_example.cpp.</p>
<h2><a class="anchor" id="linux"></a>
Linux</h2>
<p>The -std=c++11 g++ flag is required for compilation with gcc.</p>
<p>Alternatively, use the included cmake config file to build a static library and link to that:</p>
<pre>
cd directory-where-you-downloaded-argo
cmake .
make
</pre><p>Then in your own build config on the compile line:</p>
<pre>
-Idirectory-where-you-downloaded-argo
</pre><p>And on the link line: </p><pre>
-Ldirectory-where-you-downloaded-argo-largo
</pre><h2><a class="anchor" id="windoze"></a>
Windows</h2>
<p>Open Argo.vcxproj using Visual Studio 2017 (community edition works fine) and build it. If you want to incorporate it into an existing project you'll need to configure your build not to use precompiled headers for the Argo files.</p>
<p>Note that the Windows version does not provide the file description based read and write options that the Unix version does. On Windows you are limited to string, stdio and iostreams.</p>
<h1><a class="anchor" id="stuff"></a>
Bits &amp; Pieces</h1>
<p>JSON vs json - I've tried to stick to the convention of using JSON to refer to bits of text in the JSON format and json to refer to the Argo json class.</p>
<p>AVRO - the library doesn't have support for this right now but I do plan to add it at some point as I need it for another project.</p>
<p>SAX style parser - I'm not sure about this one. Does anyone really use JSON to represent anything so large and/or complex that it's a genuinely useful approach? I get why the monster than XML has become needs such a thing but I'm not convinced of its usefulness for JSON, at least not from the use cases I've observed or considered. Please tell me otherwise if you disagree.</p>
<h1><a class="anchor" id="licence"></a>
License</h1>
<p>This software is distributed under the MIT open source license.</p>
<pre>
Copyright (c) 2017 Andrew Haisley</pre><pre>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</pre><pre>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</pre><pre>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 16 2018 16:12:15 for Argo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
